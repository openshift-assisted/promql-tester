"""Condition object encapsulate condition attributes"""
import uuid
import yaml


class MalformedConfigException(Exception):
    """Exception thrown when malformed configuration file is handled"""


class FailedCondition(Exception):
    """Exception thrown when a condition fails"""


class ConditionConfigException(Exception):
    """Exception thrown when condition configuration is not valid"""


class Condition:
    """Condition class represent a condition that needs to be evaluated.
    `expression` - promql expression to be evaluated
    `for_seconds` - time period to evaluate the condition for
    `interval_seconds` - the condition will be evaluated every interval_seconds seconds
    `threshold` - threshold for the expression's result to be in for the condition to be valid
    `threshold.upper` - upper threshold
    `threshold.lower` - lower threshold
    """
    REQUIRED_FIELDS = ["expression", "for_seconds", "interval_seconds"]
    DEFAULT_THRESHOLD = {"upper": 0, "lower": 0}
    _expression: str
    _for_seconds: str
    _interval_seconds: str
    _threshold: dict
    _uuid: uuid.UUID

    def __init__(self, raw_config: dict):
        """
        raw_config: dictionary representing parsed yaml. Expected to have
        `expression`, `for_seconds`, `interval_seconds` keys.
        Optionally can have `threshold` key, which is expected to contain a dictionary
        with `upper` and `lower` keys.
        `expression` is a promql expression
        `for_seconds` are seconds that the condition needs to be evaluated for
        `interval_seconds` represent the interval of which the condition will be evaluated
        `threshold` is the threshold for which the value is expected to be in. Defaults to
        `upper` = 0 and `lower` = 0, meaning that if the result is 0 the condition is successful.
        """
        self._raise_if_error(raw_config)
        self._expression = raw_config["expression"]
        self._for_seconds = int(raw_config["for_seconds"])
        self._interval_seconds = int(raw_config["interval_seconds"])
        self._uuid = uuid.uuid4()
        self._threshold = self._get_threshold(raw_config)

    @property
    def id(self) -> str:  # pylint: disable=invalid-name
        """Returns string representation of autogenerated condition ID"""
        return str(self._uuid)

    @property
    def interval_seconds(self):
        """Returns interval seconds"""
        return self._interval_seconds

    @property
    def for_seconds(self):
        """Returns for seconds"""
        return self._for_seconds

    @property
    def expression(self):
        """Returns expression"""
        return self._expression

    def is_within_threshold(self, value):
        """Returs True if given parameter n falls within threshold, False otherwise"""
        return self._threshold["lower"] <= value <= self._threshold["upper"]

    def __repr__(self):
        """String representation for condition object"""
        return f"ID: {self.id}, " + \
            f"EXPRESSION: <{self.expression}>, " + \
            f"FOR_SECONDS: <{self.for_seconds}>, " + \
            f"INTERVAL_SECONDS: <{self.interval_seconds}>"

    def _raise_if_error(self, raw_config):
        """Raise ConditionConfigException if raw_config is not valid"""
        for field in self.REQUIRED_FIELDS:
            if field not in raw_config:
                raise ConditionConfigException(f"Field {field} not in config: {raw_config}")

    def _get_threshold(self, raw_config):
        """Returns threshold, with default values if not defined"""
        return {**self.DEFAULT_THRESHOLD, **raw_config.get("threshold", {})}


def load_conditions_from_yaml(filename: str) -> dict:
    """Returns dictionary with conditions (condition_id, condition)"""

    with open(filename, 'r', encoding='utf-8') as config_file:
        config = yaml.safe_load(config_file)
        if "conditions" not in config:
            raise MalformedConfigException(f"`conditions` key missing from {filename}")
        return [Condition(raw_condition) for raw_condition in config["conditions"]]
